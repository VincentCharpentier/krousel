{"version":3,"sources":["../src/constants.js","../src/errors.js","../src/utils/html.js","../src/utils/classNames.js","../src/components/Slider.js","../src/utils/validators.js","../src/utils/objectDiff.js","../src/utils/pick.js","../src/utils/debounce.js","index.js"],"names":["const","TRANSITION","SLIDE","FADE","DEFAULT_OPTIONS","appendArrows","appendDots","arrows","autoplay","autoplaySpeed","dots","infinite","nextArrow","pauseOnHover","prevArrow","responsive","slidesToShow","slidesToScroll","speed","swipe","transition","_forceAppendPrevArrow","_forceAppendNextArrow","draggable","rtl","KrouselError","constructor","code","errorCode","Error","ATTR_MAP","className","htmlUtils","tag","attrs","children","element","document","createElement","Object","entries","forEach","setAttribute","attr","Array","child","appendChild","classNames","classes","filter","x","join","TRANSITION_CLASS","isInstance","value","klass","VALID_TRANSITIONS","values","VALID_BP_PROPS","getEventClientX","e","touches","type","changedTouches","clientX","cancelEvent","preventDefault","Slider","target","options","_setupOptions","cleanOpts","assign","sendWarn","optName","expected","actual","console","warn","HTMLElement","name","prototype","includes","resultConf","sort","a","b","breakpoint","_target","targetArg","result","getElementById","_initialized","_currentPage","_dragInitialOffset","_showPrev","this","bind","_showNext","_enableTransition","_handleResize","_stopAutoplay","_startAutoplay","_resumeAutoplay","_pauseAutoplay","_doAutoplay","_requestNext","_requestPrev","_requestGoTo","_startDragging","_onDragMouseMove","_endDragging","_handleClickOnSlide","_computeOptions","_computeProps","_setupDOM","obj1","obj2","bpConfig","obj","conf","window","innerWidth","settings","reduce","acc","k","hasOwnProperty","_breakpoint","newOptions","_options","from","Set","keys","concat","key","_setCssVar","style","setProperty","_slideCount","_track","querySelectorAll","length","childElementCount","_pageCount","Math","ceil","min","_hasClones","_clonePerSide","props","classList","add","transitionDuration","map","replace","s","toLowerCase","v","_disableTransition","_trackContainer","_setupArrowsDOM","_setupDotsDOM","_computeSize","_setupInfiniteDOM","_computeSlidesClasses","__forceReflow","_setupListeners","slides","firstSlide","firstChild","cloneList","clonesStart","slice","clone","cloneNode","insertBefore","_prevArrow","_nextArrow","insertTarget","isConnected","_dots","remove","dotsItems","fill","__","callback","delay","timeout","addEventListener","clearTimeout","setTimeout","args","capture","d","i","handleMouseOut","currentTarget","contains","relatedTarget","slide","onStopDrag","removeEventListener","onStartDrag","_isDragging","_computeSlideIdxFromDragX","round","_slideWidth","_computeDragAmplitude","_dragStartX","_computeDragX","dragAmplitude","finalX","max","isAnimSliding","_dragStartTime","Date","now","DOMMatrix","getComputedStyle","transform","m41","amplitude","abs","dragX","currentSlideIdx","removeProperty","slideIndex","pageIndex","dragTime","absAmplitude","trackWidth","sign","_goToPage","_apStopped","_autoplayTimer","optionsChanged","_processOptionsChange","some","_cleanUpDOM","highlightIndex","domIdx","push","item","_computeArrowClasses","dotItems","__goToPage_defer","postProcess","finalPageIndex","__goToPage_timer","_reflowTrash","offsetHeight","cloneCount","clientWidth","width","index","makeKrousel","count","config","section","sectionTitle","innerHTML","configDesc","JSON","stringify","title","toString","color","backgroundColor","append","Krousel","CONFIGS","slider","querySelector"],"mappings":"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","file":"examples.cffa4e48.js","sourceRoot":"../examples","sourcesContent":["export const TRANSITION = {\n  SLIDE: 'slide',\n  FADE: 'fade',\n};\n\nexport const DEFAULT_OPTIONS = {\n  // Change where arrows are attached (default is the target)\n  appendArrows: null,\n  // Change where the navigation dots are attached\n  appendDots: null,\n  // enable or disable arrows\n  arrows: true,\n  // Auto play the carousel\n  autoplay: false,\n  // Change the interval at which autoplay change slide\n  autoplaySpeed: 3000,\n  // Display or Hide dots\n  dots: true,\n  // Enable or disable infinite behavior\n  infinite: true,\n  // Customize the \"next\" arrow\n  nextArrow: null,\n  // pause autoplay when a slide is hovered,\n  pauseOnHover: true,\n  // Customize the \"previous\" arrow\n  prevArrow: null,\n  // breakpoints config\n  responsive: null,\n  // Number of slide to show at once\n  slidesToShow: 1,\n  // Number of slide to scroll when clicking on arrow\n  slidesToScroll: 1,\n  // transition speed when changing slide\n  speed: 300,\n  // Enable swiping with touch or mouse\n  swipe: true,\n  // Change transition type when changing slide\n  // NOTE: transition 'fade' disable options slidesToShow and slidesToScroll\n  transition: TRANSITION.SLIDE,\n  // INTERNAL: move arrows elements on init\n  _forceAppendPrevArrow: false,\n  _forceAppendNextArrow: false,\n\n  // Enable dragging the slider track with touch or mouse\n  draggable: true, // TODO\n  rtl: false, // TODO\n};\n\nexport const CLASSES = {\n  root: 'krousel',\n  trackContainer: 'k-track-container',\n  track: 'k-track',\n  slide: 'k-slide',\n  slideClone: 'k-slide-cloned',\n  slideVisible: 'k-slide-visible',\n  arrowLeft: 'k-arrow-left',\n  arrowRight: 'k-arrow-right',\n  arrowDisabled: 'k-arrow-disabled',\n  dots: 'k-dots',\n  dot: 'k-dot',\n  current: 'k-current',\n  noTransition: 'k-no-transition',\n  transitionSlide: 'k-tr-slide',\n  transitionFade: 'k-tr-fade',\n};\n\nexport const CSS_VARS = {\n  slideWidth: '--slide-width',\n  slideDOMIndex: '--slide-didx',\n};\n","export default class KrouselError extends Error {\n  constructor(code) {\n    super();\n    this.errorCode = code;\n  }\n}\n\n// BAD ARGUMENTS\nexport const INVALID_TARGET = 1;\nexport const TARGET_NOT_FOUND = 2;\n","const ATTR_MAP = {\n  className: 'class',\n};\n\nconst Case = {\n  snakeToCamel(str) {\n    return str.replace(/-[A-Z]/gi, (s) => s[1].toUpperCase());\n  },\n  camelToSnake(str) {\n    return str.replace(/[A-Z]/g, (s) => '-' + s.toLowerCase());\n  },\n};\n\nconst htmlUtils = {\n  append(target, elements) {\n    let toAppend = elements;\n    if (elements instanceof HTMLCollection) {\n      toAppend = Array.from(elements);\n    }\n    if (toAppend instanceof Array) {\n      toAppend.forEach((child) => target.appendChild(child));\n    } else {\n      target.appendChild(toAppend);\n    }\n  },\n  createElement(tag, attrs = {}, children = null) {\n    let element = document.createElement(tag);\n    Object.entries(attrs).forEach(([attr, value]) => {\n      const finalAttr = ATTR_MAP[attr] || attr;\n      element.setAttribute(finalAttr, value);\n    });\n    if (children) {\n      if (children instanceof Array) {\n        children.forEach((child) => element.appendChild(child));\n      } else {\n        element.appendChild(children);\n      }\n    }\n    return element;\n  },\n  makeStyle(props) {\n    return Object.entries(props)\n      .map(([k, v]) => `${Case.camelToSnake(k)}:${v}`)\n      .join(';');\n  },\n  parseStyle(style) {\n    return Object.fromEntries(\n      style\n        .split(';')\n        .filter((x) => x.length > 0)\n        .map((rule) => rule.split(':').map((x) => x.trim()))\n        .map(([key, v]) => [Case.snakeToCamel(key), v]),\n    );\n  },\n  setElementStyle(element, styleObj) {\n    const currentStyle = this.parseStyle(element.getAttribute('style'));\n    const mergedStyle = { ...currentStyle, ...styleObj };\n    // drop null entries\n    Object.entries(mergedStyle).forEach(([k, v]) => {\n      if (v === null) {\n        delete mergedStyle[k];\n      }\n    });\n    element.setAttribute('style', this.makeStyle(mergedStyle));\n  },\n  getElementTranslateXValue(element) {\n    return new DOMMatrix(getComputedStyle(element).transform).m41;\n  },\n};\n\nexport default htmlUtils;\n","export default function classNames(...classes) {\n  return classes.filter((x) => !!x).join(' ');\n}\n","import { DEFAULT_OPTIONS, CSS_VARS, CLASSES, TRANSITION } from '../constants';\nimport KrouselError, { INVALID_TARGET } from '../errors';\nimport {\n  htmlUtils,\n  validators,\n  debounce,\n  pick,\n  objectDiff,\n  classNames,\n} from '../utils';\n\nimport './Slider.scss';\n\nconst TRANSITION_CLASS = {\n  [TRANSITION.SLIDE]: CLASSES.transitionSlide,\n  [TRANSITION.FADE]: CLASSES.transitionFade,\n};\n\nconst { isInstance, isInteger, isBoolean } = validators;\n\nfunction getTarget(targetArg) {\n  let result = targetArg;\n  if (typeof targetArg === 'string') {\n    result = document.getElementById(targetArg);\n  } else if (isInstance(targetArg, HTMLElement)) {\n    result = targetArg;\n  } else {\n    throw new KrouselError(INVALID_TARGET);\n  }\n  return result;\n}\n\nconst VALID_TRANSITIONS = Object.values(TRANSITION);\nfunction mergeOptions(options) {\n  let cleanOpts = Object.assign({}, options);\n  // generic warn function\n  const sendWarn = (optName, expected, actual) =>\n    console.warn(\n      `Krousel - Invalid option '${optName}' will be ignored. Expected ${expected}, got: ${actual}`,\n    );\n  // validate options\n  const { appendDots, transition } = options;\n  if (appendDots && !isInstance(appendDots, HTMLElement)) {\n    // erase option\n    let actual =\n      (appendDots.constructor && appendDots.constructor.name) ||\n      (appendDots.prototype && appendDots.prototype.name) ||\n      appendDots;\n    sendWarn('appendDots', 'HTMLElement', actual);\n    delete cleanOpts.appendDots;\n  }\n\n  if (transition && !VALID_TRANSITIONS.includes(transition)) {\n    sendWarn('transition', `oneOf ${VALID_TRANSITIONS.join('|')}`, transition);\n    delete cleanOpts.transition;\n  }\n\n  // merge with defaults\n  let resultConf = Object.assign({}, DEFAULT_OPTIONS, cleanOpts);\n\n  if (resultConf.responsive) {\n    // sort responsive configs by breakpoints size ASC\n    resultConf.responsive.sort((a, b) => a.breakpoint - b.breakpoint);\n  }\n\n  return resultConf;\n}\n\n/**\n * Valid properties in responsive[*].settings\n * @type {string[]}\n */\nconst VALID_BP_PROPS = ['slidesToShow', 'slidesToScroll', 'infinite'];\n\n/**\n * Compute which breakpoint config to use based on screen size\n * @param options\n * @return {null}\n */\nfunction getBreakpointConfig(options) {\n  const { responsive } = options;\n  let bpConfig = null;\n  if (responsive) {\n    // find the relevant config\n    for (let conf of responsive) {\n      if (window.innerWidth <= conf.breakpoint) {\n        // responsive is sorted by breakpoint size ASC\n        // first match is the relevant one\n        // we can stop here\n        bpConfig = conf;\n        break;\n      }\n    }\n    if (bpConfig) {\n      // keep only valid options\n      bpConfig.settings = pick(bpConfig.settings, VALID_BP_PROPS);\n    }\n  }\n  return bpConfig;\n}\n\n/**\n * compute X position of a touch or mouse event\n * @param e native event\n * @return {number}\n */\nfunction getEventClientX(e) {\n  let result = 0;\n  if (e.touches) {\n    // touch event\n    if (e.type === 'touchend') {\n      result = e.changedTouches[0].clientX;\n    } else {\n      result = e.touches[0].clientX;\n    }\n  } else {\n    result = e.clientX;\n  }\n  return result;\n}\n\nfunction cancelEvent(e) {\n  e.preventDefault();\n}\n\nexport default class Slider {\n  constructor(target, options) {\n    this._setupOptions = mergeOptions(options);\n    this._target = getTarget(target);\n\n    // init props\n    this._initialized = false;\n    this._currentPage = 0;\n    this._dragInitialOffset = 0;\n\n    this._showPrev = this._showPrev.bind(this);\n    this._showNext = this._showNext.bind(this);\n    this._enableTransition = this._enableTransition.bind(this);\n    this._handleResize = this._handleResize.bind(this);\n    this._stopAutoplay = this._stopAutoplay.bind(this);\n    this._startAutoplay = this._startAutoplay.bind(this);\n    this._resumeAutoplay = this._resumeAutoplay.bind(this);\n    this._pauseAutoplay = this._pauseAutoplay.bind(this);\n    this._doAutoplay = this._doAutoplay.bind(this);\n    this._requestNext = this._requestNext.bind(this);\n    this._requestPrev = this._requestPrev.bind(this);\n    this._requestGoTo = this._requestGoTo.bind(this);\n    this._startDragging = this._startDragging.bind(this);\n    this._onDragMouseMove = this._onDragMouseMove.bind(this);\n    this._endDragging = this._endDragging.bind(this);\n    this._handleClickOnSlide = this._handleClickOnSlide.bind(this);\n\n    this._computeOptions();\n    this._computeProps();\n    this._setupDOM();\n    this._initialized = true;\n    this._startAutoplay();\n  }\n\n  _computeOptions() {\n    let result = {};\n    const bpConfig = getBreakpointConfig(this._setupOptions);\n    if (bpConfig !== this._breakpoint) {\n      const newOptions = Object.assign(\n        {},\n        this._setupOptions,\n        bpConfig && bpConfig.settings,\n      );\n\n      if (this._options) {\n        result = objectDiff(this._options, newOptions);\n      }\n\n      this._breakpoint = bpConfig;\n      this._options = newOptions;\n    }\n    return result;\n  }\n\n  _setCssVar(name, value) {\n    this._target.style.setProperty(name, value);\n  }\n\n  _computeProps() {\n    const {\n      infinite,\n      slidesToShow,\n      slidesToScroll,\n      transition,\n    } = this._options;\n    if (!this._initialized) {\n      this._slideCount = this._target.childElementCount;\n    } else {\n      const selector = `.${CLASSES.slide}:not(.${CLASSES.slideClone})`;\n      this._slideCount = this._track.querySelectorAll(selector).length;\n    }\n    this._pageCount = Math.ceil(\n      (this._slideCount + slidesToScroll - slidesToShow) / slidesToScroll,\n    );\n    // bound current page to page count\n    this._currentPage = Math.min(this._currentPage, this._pageCount - 1);\n    this._hasClones = infinite && transition === TRANSITION.SLIDE;\n    this._clonePerSide = this._hasClones ? 2 * slidesToShow : 0;\n  }\n\n  /**\n   * Setup DOM\n   * @private\n   */\n  _setupDOM() {\n    const { transition, speed } = this._options;\n\n    const children = Array.from(this._target.children);\n\n    this._target.classList.add(CLASSES.root);\n\n    this._track = htmlUtils.createElement('div', {\n      className: classNames(CLASSES.track, TRANSITION_CLASS[transition]),\n      style: htmlUtils.makeStyle({\n        transitionDuration: `${speed}ms`,\n      }),\n    });\n    this._disableTransition();\n\n    this._trackContainer = htmlUtils.createElement(\n      'div',\n      {\n        className: CLASSES.trackContainer,\n      },\n      this._track,\n    );\n\n    this._target.appendChild(this._trackContainer);\n\n    this._setupArrowsDOM();\n    this._setupDotsDOM();\n\n    this._setCssVar(CSS_VARS.slideDOMIndex, this._clonePerSide);\n\n    this._computeSize();\n\n    children.forEach((child) => {\n      if (child instanceof HTMLElement) {\n        child.classList.add(CLASSES.slide);\n        this._track.appendChild(child);\n      }\n    });\n\n    if (this._hasClones) {\n      this._setupInfiniteDOM();\n    }\n\n    this._computeSlidesClasses(0);\n\n    // force reflow before activating transitions\n    this.__forceReflow();\n    this._enableTransition();\n\n    // setup listeners\n    this._setupListeners();\n  }\n\n  _setupInfiniteDOM() {\n    const slides = Array.from(\n      this._track.querySelectorAll(`.${CLASSES.slide}`),\n    );\n    const firstSlide = this._track.firstChild;\n    let cloneList = slides;\n    while (cloneList.length < this._clonePerSide) {\n      cloneList = cloneList.concat(slides);\n    }\n    const clonesStart = cloneList.slice(-this._clonePerSide).map((child) => {\n      const clone = child.cloneNode(true);\n      clone.classList.add(CLASSES.slideClone);\n      return clone;\n    });\n    cloneList.slice(0, this._clonePerSide).forEach((child) => {\n      const clone = child.cloneNode(true);\n      clone.classList.add(CLASSES.slideClone);\n      this._track.appendChild(clone);\n    });\n    clonesStart.forEach((clone) => this._track.insertBefore(clone, firstSlide));\n  }\n\n  _setupArrowsDOM() {\n    const {\n      _forceAppendPrevArrow,\n      _forceAppendNextArrow,\n      appendArrows,\n      arrows,\n      nextArrow,\n      prevArrow,\n    } = this._options;\n    if (arrows) {\n      this._prevArrow = prevArrow || htmlUtils.createElement('div');\n      this._prevArrow.classList.add(CLASSES.arrowLeft);\n      this._nextArrow = nextArrow || htmlUtils.createElement('div');\n      this._nextArrow.classList.add(CLASSES.arrowRight);\n      let insertTarget = appendArrows || this._trackContainer;\n      // append prevArrow if appendArrow is specified or if it was not already connected to DOM\n      if (_forceAppendPrevArrow || !this._prevArrow.isConnected) {\n        // append at first position\n        if (insertTarget.childElementCount > 0) {\n          insertTarget.insertBefore(this._prevArrow, insertTarget.firstChild);\n        } else {\n          insertTarget.appendChild(this._prevArrow);\n        }\n      }\n\n      // append nextArrow if appendArrow is specified or if it was not already connected to DOM\n      if (_forceAppendNextArrow || !this._nextArrow.isConnected) {\n        // append at last position\n        insertTarget.appendChild(this._nextArrow);\n      }\n    }\n  }\n\n  _setupDotsDOM() {\n    const { appendDots, dots } = this._options;\n    if (dots) {\n      if (this._dots) {\n        // remove existing DOM\n        this._dots.remove();\n      }\n      // create each dot\n      const dotsItems = new Array(this._pageCount)\n        .fill(null)\n        .map((__) =>\n          htmlUtils.createElement('div', { className: CLASSES.dot }),\n        );\n      this._dots = htmlUtils.createElement(\n        'div',\n        {\n          className: CLASSES.dots,\n        },\n        dotsItems,\n      );\n\n      let container = appendDots || this._target;\n      container.appendChild(this._dots);\n    }\n  }\n\n  _setupListeners() {\n    const { arrows, dots, autoplay, pauseOnHover, swipe } = this._options;\n    window.addEventListener('resize', debounce(this._handleResize, 100));\n    this._track.querySelectorAll(`.${CLASSES.slide}`).forEach((element) =>\n      element.addEventListener('click', this._handleClickOnSlide, {\n        capture: true,\n      }),\n    );\n    if (arrows) {\n      this._prevArrow.addEventListener('click', this._requestPrev);\n      this._nextArrow.addEventListener('click', this._requestNext);\n    }\n    if (dots) {\n      this._dots\n        .querySelectorAll(`.${CLASSES.dot}`)\n        .forEach((d, i) =>\n          d.addEventListener('click', () => this._requestGoTo(i)),\n        );\n    }\n    if (autoplay) {\n      let slides = this._track.querySelectorAll(`.${CLASSES.slide}`);\n      const handleMouseOut = (e) => {\n        const doStart = !e.currentTarget.contains(e.relatedTarget);\n        if (doStart) {\n          this._resumeAutoplay();\n        }\n      };\n      if (pauseOnHover) {\n        slides.forEach((slide) => {\n          slide.addEventListener('mouseenter', this._pauseAutoplay);\n          slide.addEventListener('mouseout', handleMouseOut);\n        });\n      }\n    }\n    if (swipe) {\n      const onStopDrag = (e) => {\n        window.removeEventListener('mousemove', this._onDragMouseMove);\n        window.removeEventListener('touchmove', this._onDragMouseMove);\n        window.removeEventListener('mouseup', onStopDrag);\n        window.removeEventListener('touchend', onStopDrag);\n        this._track\n          .querySelectorAll(`.${CLASSES.slide}`)\n          .forEach((element) =>\n            element.removeEventListener('dragstart', cancelEvent),\n          );\n        this._endDragging(e);\n      };\n      const onStartDrag = (e) => {\n        window.addEventListener('mouseup', onStopDrag);\n        window.addEventListener('touchend', onStopDrag);\n        window.addEventListener('mousemove', this._onDragMouseMove);\n        window.addEventListener('touchmove', this._onDragMouseMove);\n        this._track\n          .querySelectorAll(`.${CLASSES.slide}`)\n          .forEach((element) =>\n            element.addEventListener('dragstart', cancelEvent),\n          );\n\n        this._startDragging(e);\n      };\n      this._track.addEventListener('mousedown', onStartDrag);\n      this._track.addEventListener('touchstart', onStartDrag);\n    }\n  }\n\n  _handleClickOnSlide(e) {\n    if (this._isDragging) {\n      cancelEvent(e);\n      this._isDragging = false;\n    }\n  }\n\n  _computeSlideIdxFromDragX(x) {\n    const { transition, slidesToShow } = this._options;\n    let result = Math.round(-x / this._slideWidth - this._clonePerSide);\n    if (transition !== TRANSITION.SLIDE) {\n      // fade transition: result is how many slides were swiped\n      // add current slide index\n      result += this._currentPage * slidesToShow;\n    }\n    return result;\n  }\n\n  _computeDragAmplitude(e) {\n    const clientX = getEventClientX(e);\n    return clientX - this._dragStartX;\n  }\n\n  _computeDragX(dragAmplitude) {\n    const { infinite } = this._options;\n    let finalX = this._dragInitialOffset + dragAmplitude;\n    if (!infinite) {\n      // limit drag effect in finite slider\n      const minBound = -this._slideWidth * (this._slideCount - 1);\n      finalX = Math.min(Math.max(finalX, minBound), 0);\n    }\n    return finalX;\n  }\n\n  _startDragging(e) {\n    const { transition } = this._options;\n    const isAnimSliding = transition === TRANSITION.SLIDE;\n    this._dragStartX = getEventClientX(e);\n    this._dragStartTime = Date.now();\n    this._dragInitialOffset = isAnimSliding\n      ? htmlUtils.getElementTranslateXValue(this._track)\n      : 0;\n    this._pauseAutoplay();\n    if (isAnimSliding) {\n      this._disableTransition();\n    }\n  }\n\n  _onDragMouseMove(e) {\n    const { transition } = this._options;\n    const amplitude = this._computeDragAmplitude(e);\n    if (!this._isDragging && Math.abs(amplitude) > 50) {\n      // this will disable click on slides until drag is over\n      this._isDragging = true;\n    }\n    const dragX = this._computeDragX(amplitude);\n    if (transition === TRANSITION.SLIDE) {\n      // make track follow input\n      this._track.style.setProperty('--dX', dragX + 'px');\n    }\n    // update slide display according to drag position\n    const currentSlideIdx = this._computeSlideIdxFromDragX(dragX);\n    this._computeSlidesClasses(currentSlideIdx);\n  }\n\n  _endDragging(e) {\n    const { slidesToScroll, slidesToShow, infinite } = this._options;\n    const amplitude = this._computeDragAmplitude(e);\n    const dragX = this._computeDragX(amplitude);\n    // do not immediately update state, we could have a click to cancel after the mouseup event\n    setTimeout(() => {\n      this._isDragging = false;\n    }, 250);\n\n    // re-enable transition\n    this._enableTransition();\n\n    // remove css var overwrite\n    this._track.style.removeProperty('--dX');\n\n    // snap to closest page\n    const slideIndex = this._computeSlideIdxFromDragX(dragX);\n    let pageIndex = Math.round(slideIndex / slidesToScroll);\n\n    if (pageIndex === this._currentPage) {\n      // check if gesture was a quick slide\n      const dragTime = Date.now() - this._dragStartTime;\n      const absAmplitude = Math.abs(amplitude);\n      const trackWidth = slidesToShow * this._slideWidth;\n      // quick drag with reasonable amplitude is considered swipe next/prev\n      if (\n        dragTime < 500 &&\n        absAmplitude > trackWidth * 0.3 &&\n        absAmplitude < trackWidth\n      ) {\n        pageIndex = this._currentPage - Math.sign(amplitude);\n      }\n    }\n    if (!infinite) {\n      pageIndex = Math.min(Math.max(0, pageIndex), this._pageCount - 1);\n    }\n    this._goToPage(pageIndex);\n    this._resumeAutoplay();\n  }\n\n  _startAutoplay() {\n    const { autoplay } = this._options;\n    if (autoplay) {\n      this._apStopped = false;\n      this._resumeAutoplay();\n    }\n  }\n\n  _pauseAutoplay() {\n    clearTimeout(this._autoplayTimer);\n  }\n\n  _resumeAutoplay() {\n    const { autoplay, autoplaySpeed } = this._options;\n    if (autoplay && !this._apStopped) {\n      // make sure we were stopped\n      clearTimeout(this._autoplayTimer);\n      this._autoplayTimer = setTimeout(this._doAutoplay, autoplaySpeed);\n    }\n  }\n\n  _stopAutoplay() {\n    this._apStopped = true;\n    this._pauseAutoplay();\n  }\n\n  _doAutoplay() {\n    const { speed, autoplaySpeed } = this._options;\n    this._showNext();\n    this._autoplayTimer = setTimeout(this._doAutoplay, autoplaySpeed + speed);\n  }\n\n  _handleResize() {\n    const { responsive } = this._options;\n    this._disableTransition();\n\n    if (responsive) {\n      const optionsChanged = this._computeOptions();\n      this._computeProps();\n      this._processOptionsChange(optionsChanged);\n    }\n\n    this._computeSize();\n\n    if (responsive) {\n      this._setupDotsDOM();\n      this._goToPage(this._currentPage);\n    }\n\n    // force reflow before re-activating transitions\n    this.__forceReflow();\n    this._enableTransition();\n  }\n\n  _processOptionsChange(optionsChanged) {\n    const anyChanged = (props) =>\n      props.some((x) => optionsChanged.hasOwnProperty(x));\n\n    if (anyChanged(['infinite', 'slidesToShow'])) {\n      // recompute infinite\n      // destroy clones anyway\n      this._track\n        .querySelectorAll(`.${CLASSES.slideClone}`)\n        .forEach((e) => e.remove());\n\n      if (this._hasClones) {\n        this._setupInfiniteDOM();\n      }\n    }\n  }\n\n  /**\n   * Revert changes made to the DOM upon destroy\n   * @private\n   */\n  _cleanUpDOM() {\n    // TODO\n  }\n\n  /**\n   * Update all classes for a given slide display\n   * @param slideIndex\n   * @private\n   */\n  _computeSlidesClasses(slideIndex) {\n    const { dots, slidesToShow } = this._options;\n    const highlightIndex = [];\n    for (let i = slideIndex; i < slideIndex + slidesToShow; i++) {\n      const domIdx = i + this._clonePerSide;\n      highlightIndex.push(domIdx);\n      if (i < 0) {\n        highlightIndex.push(domIdx + this._slideCount);\n      } else if (i >= this._slideCount) {\n        highlightIndex.push(domIdx - this._slideCount);\n      }\n    }\n\n    this._track.querySelectorAll(`.${CLASSES.slide}`).forEach((item, i) => {\n      if (highlightIndex.includes(i)) {\n        item.classList.add(CLASSES.slideVisible);\n      } else {\n        item.classList.remove(CLASSES.slideVisible);\n      }\n    });\n\n    // ARROWS\n    this._computeArrowClasses();\n\n    // DOTS\n    if (dots) {\n      const dotItems = this._dots.querySelectorAll(`.${CLASSES.dot}`);\n      dotItems.forEach((item) => item.classList.remove(CLASSES.current));\n      if (dotItems.length > 0) {\n        dotItems[this._currentPage].classList.add(CLASSES.current);\n      }\n    }\n  }\n\n  _computeArrowClasses() {\n    const { arrows, infinite } = this._options;\n    if (arrows) {\n      if (!infinite) {\n        if (this._currentPage === 0) {\n          this._prevArrow.classList.add(CLASSES.arrowDisabled);\n        } else {\n          this._prevArrow.classList.remove(CLASSES.arrowDisabled);\n        }\n        if (this._currentPage === this._pageCount - 1) {\n          this._nextArrow.classList.add(CLASSES.arrowDisabled);\n        } else {\n          this._nextArrow.classList.remove(CLASSES.arrowDisabled);\n        }\n      } else {\n        this._prevArrow.classList.remove(CLASSES.arrowDisabled);\n        this._nextArrow.classList.remove(CLASSES.arrowDisabled);\n      }\n    }\n  }\n\n  _goToPage(pageIndex) {\n    // if a goto postprocess were deferred\n    if (this.__goToPage_defer) {\n      // execute immediately the deferred callback\n      this.__goToPage_defer();\n      // re-process goto instruction before next render\n      this._goToPage(pageIndex);\n      return;\n    }\n    const { slidesToShow, slidesToScroll, speed } = this._options;\n\n    let postProcess = false,\n      finalPageIndex = pageIndex;\n    if (pageIndex >= this._pageCount) {\n      finalPageIndex = 0;\n      postProcess = true;\n    } else if (pageIndex < 0) {\n      finalPageIndex = this._pageCount - 1;\n      postProcess = true;\n    }\n    this._currentPage = finalPageIndex;\n    let slideIndex;\n    if (pageIndex >= this._pageCount) {\n      slideIndex = this._slideCount;\n    } else if (pageIndex < 0) {\n      slideIndex = -slidesToShow;\n    } else {\n      slideIndex = pageIndex * slidesToScroll;\n    }\n\n    if (\n      pageIndex === this._pageCount - 1 &&\n      slideIndex > this._slideCount - slidesToShow\n    ) {\n      // last page might be incomplete if slideCount % slidesToShow != 0\n      slideIndex = this._slideCount - slidesToShow;\n    }\n\n    // Clamp slideIndex to prevent going too far in clones\n    slideIndex = Math.min(\n      Math.max(slideIndex, -slidesToShow),\n      this._slideCount,\n    );\n\n    // UPDATE CLASSES\n    this._computeSlidesClasses(slideIndex);\n\n    const slideDOMIndex = slideIndex + this._clonePerSide;\n    this._setCssVar(CSS_VARS.slideDOMIndex, slideDOMIndex);\n    if (postProcess) {\n      // The defered callback occured when we transition to a clone slide\n      // it will translate to the original slide without transition\n      this.__goToPage_defer = () => {\n        delete this.__goToPage_defer;\n        clearTimeout(this.__goToPage_timer);\n        // teleport back to index within bounds (after sliding in clones)\n        this._disableTransition();\n        this._goToPage(finalPageIndex);\n        // Trigger a reflow, flushing the CSS changes\n        this.__forceReflow();\n        // Re-enable CSS after reflow\n        this._enableTransition();\n      };\n      // execute after the transition is complete\n      this.__goToPage_timer = setTimeout(this.__goToPage_defer, speed);\n    }\n  }\n\n  /**\n   * Force browser to trigger a reflow\n   * Useful after CSS changes and before (re)enabling transitions\n   * @private\n   */\n  __forceReflow() {\n    // value must be read to avoid browser optimizations that would skip useless reflow\n    this._reflowTrash = this._track.offsetHeight; // DO NOT REMOVE\n  }\n\n  _enableTransition() {\n    this._track.classList.remove(CLASSES.noTransition);\n  }\n\n  _disableTransition() {\n    this._track.classList.add(CLASSES.noTransition);\n  }\n\n  _computeSize() {\n    const { slidesToShow, transition } = this._options;\n    const cloneCount = 2 * this._clonePerSide;\n    const sliderWidth = this._trackContainer.clientWidth;\n    this._slideWidth = sliderWidth / slidesToShow;\n    this._setCssVar(CSS_VARS.slideWidth, this._slideWidth + 'px');\n    if (transition === TRANSITION.SLIDE) {\n      this._track.style.width = `${(cloneCount + this._slideCount) *\n        this._slideWidth +\n        1000}px`;\n    }\n  }\n\n  _showNext() {\n    const { infinite } = this._options;\n    if (infinite || this._currentPage < this._pageCount - 1) {\n      this._goToPage(this._currentPage + 1);\n    }\n  }\n\n  _showPrev() {\n    const { infinite } = this._options;\n    if (infinite || this._currentPage > 0) {\n      this._goToPage(this._currentPage - 1);\n    }\n  }\n\n  /**\n   * User request to show next slide\n   * @private\n   */\n  _requestNext() {\n    this._stopAutoplay();\n    this._showNext();\n  }\n\n  /**\n   * User request to show prev slide\n   * @private\n   */\n  _requestPrev() {\n    this._stopAutoplay();\n    this._showPrev();\n  }\n\n  /**\n   * User request to show a specific slide\n   * @param index\n   * @private\n   */\n  _requestGoTo(index) {\n    this._stopAutoplay();\n    this._goToPage(index);\n  }\n}\n","export function isInstance(value, klass) {\n  return value instanceof klass;\n}\n\nexport function isInteger(value) {\n  return typeof value === 'number' && !isNaN(value) && isFinite(value);\n}\n\nexport function isBoolean(value) {\n  return typeof value === 'boolean';\n}\n","/**\n * Return an object with the properties that are different in first and second param\n * @param obj1 first object\n * @param obj2 second object\n * @return {{}}\n */\nexport default function objectDiff(obj1, obj2) {\n  let allKeys = Array.from(\n    new Set(Object.keys(obj1).concat(Object.keys(obj2))),\n  );\n  return allKeys.reduce((acc, key) => {\n    if (obj1[key] !== obj2[key]) acc[key] = obj2[key];\n    return acc;\n  }, {});\n}\n","/**\n * pick only a set of properties from an object\n * @param obj source object\n * @param props array of props to pick\n * @return new object with only the picked properties\n */\nexport default function pick(obj, props) {\n  return props.reduce((acc, k) => {\n    if (obj.hasOwnProperty(k)) {\n      acc[k] = obj[k];\n    }\n    return acc;\n  }, {});\n}\n","export default function debounce(callback, delay) {\n  let timeout;\n  return function(...args) {\n    clearTimeout(timeout);\n    timeout = setTimeout(callback, delay, ...args);\n  };\n}\n","import Krousel from '../dist/krousel';\n\nfunction makeKrousel({ count = 5, name = '', className, ...config }) {\n  let section = document.createElement('section');\n  if (className) {\n    section.classList.add(className);\n  }\n  let sectionTitle = document.createElement('h1');\n  sectionTitle.innerHTML = name;\n  section.appendChild(sectionTitle);\n  let configDesc = document.createElement('pre');\n  configDesc.innerHTML = JSON.stringify(\n    config,\n    (key, value) => {\n      if (value instanceof HTMLElement) {\n        return value.constructor.name;\n      }\n      return value;\n    },\n    2,\n  );\n  section.appendChild(configDesc);\n  let target = document.createElement('div');\n  section.appendChild(target);\n  new Array(count).fill(null).forEach((__, i) => {\n    let slide = document.createElement('div');\n    let title = document.createElement('h3');\n    title.innerHTML = (i + 1).toString();\n    const color = Math.round((i / count) * 360);\n    title.style.backgroundColor = `hsl(${color}, 60%, 60%)`;\n    slide.appendChild(title);\n    target.append(slide);\n  });\n  document.getElementById('target').appendChild(section);\n  new Krousel(target, config);\n}\n\nconst CONFIGS = [\n  {\n    name: 'Simple demo',\n    count: 5,\n    infinite: false,\n  },\n  {\n    name: 'Infinite loop (default)',\n    count: 5,\n    infinite: true,\n  },\n  {\n    name: 'Transition speed',\n    count: 5,\n    speed: 1000,\n    className: 'slow',\n  },\n  {\n    name: 'Transition Type',\n    count: 5,\n    transition: 'fade',\n  },\n  {\n    name: 'Autoplay (pause when hovered)',\n    count: 2,\n    autoplay: true,\n    autoplaySpeed: 3000,\n    pauseOnHover: true,\n    infinite: true,\n  },\n  {\n    name: 'Disable arrows',\n    count: 5,\n    arrows: false,\n    autoplay: true,\n  },\n  {\n    name: 'Show multiple',\n    count: 5,\n    slidesToShow: 2,\n  },\n  {\n    name: 'Scroll multiple',\n    count: 5,\n    slidesToShow: 2,\n    slidesToScroll: 2,\n  },\n  {\n    name: 'Scroll multiple',\n    count: 25,\n    slidesToShow: 4,\n    slidesToScroll: 3,\n  },\n  {\n    name: 'Hide dots',\n    count: 5,\n    dots: false,\n  },\n  {\n    name: 'Responsive',\n    count: 10,\n    slidesToShow: 3,\n    slidesToScroll: 3,\n    responsive: [\n      {\n        breakpoint: 600,\n        settings: {\n          slidesToShow: 2,\n          slidesToScroll: 2,\n        },\n      },\n      {\n        breakpoint: 400,\n        settings: {\n          infinite: false,\n          slidesToShow: 1,\n          slidesToScroll: 1,\n        },\n      },\n    ],\n  },\n];\n\nwindow.addEventListener('load', function() {\n  CONFIGS.map(makeKrousel);\n  let section = document.getElementById('hoverEffect');\n  let slider = section.querySelector('.slider');\n  new Krousel(slider, {\n    slidesToShow: 3,\n    appendArrows: slider,\n    appendDots: section,\n  });\n\n  // do krousel with custom inserts\n  section = document.getElementById('customTargets');\n  section.querySelector('pre').innerHTML = `{\n  appendDots: HTMLElement\n  appendArrows: HTMLElement\n}`;\n  new Krousel(section.querySelector('.slider'), {\n    appendDots: section.querySelector('.top-zone'),\n    appendArrows: section.querySelector('.top-zone'),\n  });\n\n  section = document.getElementById('customArrows');\n  section.querySelector('pre').innerHTML = `{\n  prevArrow: HTMLElement\n  nextArrow: HTMLElement\n}`;\n  new Krousel(section.querySelector('.slider'), {\n    prevArrow: section.querySelector('.go-prev'),\n    nextArrow: section.querySelector('.go-next'),\n  });\n});\n"]}